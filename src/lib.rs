#![no_std]

extern crate embedded_hal as hal;

#[cfg(feature = "std")]
extern crate std;

#[cfg(feature = "std")]
use core::time::Duration;
#[cfg(feature = "std")]
use std::thread::sleep;

use core::fmt::{self, Display, Formatter};
use hal::spi::SpiDevice;

#[macro_use]
pub mod lowlevel;
mod types;

pub use lowlevel::{access::*, convert::*, registers::*};
pub use lowlevel::{types::*, FIFO_SIZE_MAX};
pub use types::*;

/// CC1101 errors.
#[derive(Copy, Clone, Debug, Eq, PartialEq)]
pub enum Error<SpiE> {
    /// The TX FIFO buffer underflowed, too large packet for configured packet length.
    TxUnderflow,
    /// The RX FIFO buffer overflowed, too small buffer for configured packet length.
    RxOverflow,
    /// Corrupt packet received with invalid CRC.
    CrcMismatch,
    /// Invalid state read from MARCSTATE register
    InvalidState(u8),
    /// User Input Error
    UserInputError(UserError),
    /// Platform-dependent SPI-errors, such as IO errors.
    Spi(SpiE),
}

/// Errors generated by user.
#[derive(Copy, Clone, Debug, Eq, PartialEq)]
pub enum UserError {
    /// Missing Length parameter
    MissingLengthParameter,
    /// Missing Address parameter
    MissingAddressParameter,
    /// Array too long
    ArrayTooLong(usize),
}

impl<SpiE> From<SpiE> for Error<SpiE> {
    fn from(e: SpiE) -> Self {
        Error::Spi(e)
    }
}

impl<SpiE: Display> Display for Error<SpiE> {
    fn fmt(&self, f: &mut Formatter) -> fmt::Result {
        match self {
            Self::TxUnderflow => write!(f, "TX FIFO buffer underflowed"),
            Self::RxOverflow => write!(f, "RX FIFO buffer overflowed"),
            Self::CrcMismatch => write!(f, "CRC mismatch"),
            Self::InvalidState(s) => write!(f, "Invalid state: {}", s),
            Self::UserInputError(e) => match e {
                UserError::MissingLengthParameter => {
                    write!(f, "User error: Missing length parameter")
                }
                UserError::MissingAddressParameter => {
                    write!(f, "User error: Missing address parameter")
                }
                UserError::ArrayTooLong(v) => write!(f, "User error: Array too long: {}", v),
            },
            Self::Spi(e) => write!(f, "SPI error: {}", e),
        }
    }
}

#[cfg(feature = "std")]
impl<SpiE: Display + core::fmt::Debug> std::error::Error for Error<SpiE> {}

/// High level API for interacting with the CC1101 radio chip.
pub struct Cc1101<SPI>(lowlevel::Cc1101<SPI>);

impl<SPI, SpiE> Cc1101<SPI>
where
    SPI: SpiDevice<u8, Error = SpiE>,
{
    pub fn new(spi: SPI) -> Result<Self, Error<SpiE>> {
        Ok(Cc1101(lowlevel::Cc1101::new(spi)?))
    }

    /// Last Chip Status Byte
    pub fn get_chip_status(&mut self) -> Option<StatusByte> {
        self.0.status
    }

    /// Fetch the current state of the chip
    /// Due to errata note, we need to read the status register twice by issuing a NOP command.
    pub fn fetch_chip_state(&mut self) -> Result<State, Error<SpiE>> {
        self.no_operation()?;
        let mut old_state = self.get_chip_status().unwrap();
        loop {
            // we read 2 times due to errata note
            self.no_operation()?;
            let state = self.get_chip_status().unwrap();

            if state == old_state {
                return Ok(state.state);
            }
            old_state = state;

            #[cfg(feature = "std")]
            sleep(Duration::from_millis(20));
        }
    }

    /// Command Strobe: Reset chip
    pub fn reset_chip(&mut self) -> Result<(), Error<SpiE>> {
        self.0.write_cmd_strobe(Command::SRES)?;
        Ok(())
    }

    /// Command Strobe: Enable and calibrate frequency synthesizer
    pub fn enable_and_cal_freq_synth(&mut self) -> Result<(), Error<SpiE>> {
        self.0.write_cmd_strobe(Command::SFSTXON)?;
        Ok(())
    }

    /// Command Strobe: Turn off crystal oscillator
    pub fn turn_off_xosc(&mut self) -> Result<(), Error<SpiE>> {
        self.0.write_cmd_strobe(Command::SXOFF)?;
        Ok(())
    }

    /// Command Strobe: Calibrate frequency synthesizer and turn it off
    pub fn cal_freq_synth_and_turn_off(&mut self) -> Result<(), Error<SpiE>> {
        self.0.write_cmd_strobe(Command::SCAL)?;
        Ok(())
    }

    /// Command Strobe: Enable RX
    pub fn enable_rx(&mut self) -> Result<(), Error<SpiE>> {
        self.0.write_cmd_strobe(Command::SRX)?;
        Ok(())
    }

    /// Command Strobe: Enable TX
    pub fn enable_tx(&mut self) -> Result<(), Error<SpiE>> {
        self.0.write_cmd_strobe(Command::STX)?;
        Ok(())
    }

    /// Command Strobe: Exit RX / TX, turn off frequency synthesizer
    pub fn exit_rx_tx(&mut self) -> Result<(), Error<SpiE>> {
        self.0.write_cmd_strobe(Command::SIDLE)?;
        Ok(())
    }

    /// Command Strobe: Start automatic RX polling sequence (Wake-on-Radio)
    pub fn start_wake_on_radio(&mut self) -> Result<(), Error<SpiE>> {
        self.0.write_cmd_strobe(Command::SWOR)?;
        Ok(())
    }

    /// Command Strobe: Enter power down mode when CSn goes high
    pub fn enter_power_down_mode(&mut self) -> Result<(), Error<SpiE>> {
        self.0.write_cmd_strobe(Command::SPWD)?;
        Ok(())
    }

    /// Command Strobe: Flush the RX FIFO buffer
    pub fn flush_rx_fifo_buffer(&mut self) -> Result<(), Error<SpiE>> {
        self.0.write_cmd_strobe(Command::SFRX)?;
        Ok(())
    }

    /// Command Strobe: Flush the TX FIFO buffer
    pub fn flush_tx_fifo_buffer(&mut self) -> Result<(), Error<SpiE>> {
        self.0.write_cmd_strobe(Command::SFTX)?;
        Ok(())
    }

    /// Command Strobe: Reset real time clock to Event1 value
    pub fn reset_rtc_to_event1(&mut self) -> Result<(), Error<SpiE>> {
        self.0.write_cmd_strobe(Command::SWORRST)?;
        Ok(())
    }

    /// Command Strobe: No operation. May be used to get access to the chip status byte
    pub fn no_operation(&mut self) -> Result<(), Error<SpiE>> {
        self.0.write_cmd_strobe(Command::SNOP)?;
        Ok(())
    }

    pub fn set_fscal1(&mut self, value: u8) -> Result<(), Error<SpiE>> {
        self.0.write_register(Config::FSCAL1, value)?;
        Ok(())
    }

    pub fn set_fscal0(&mut self, value: u8) -> Result<(), Error<SpiE>> {
        self.0.write_register(Config::FSCAL0, value)?;
        Ok(())
    }

    pub fn set_test2(&mut self, test2: u8) -> Result<(), Error<SpiE>> {
        self.0.write_register(Config::TEST2, test2)?;
        Ok(())
    }

    pub fn set_test1(&mut self, test1: u8) -> Result<(), Error<SpiE>> {
        self.0.write_register(Config::TEST1, test1)?;
        Ok(())
    }

    /// Sets the carrier frequency (in Hertz).
    pub fn set_frequency(&mut self, hz: u64) -> Result<(), Error<SpiE>> {
        let (freq0, freq1, freq2) = from_frequency(hz);
        self.0.write_register(Config::FREQ0, freq0)?;
        self.0.write_register(Config::FREQ1, freq1)?;
        self.0.write_register(Config::FREQ2, freq2)?;
        Ok(())
    }

    pub fn set_channel_number(&mut self, channel: u8) -> Result<(), Error<SpiE>> {
        self.0.write_register(Config::CHANNR, channel)?;
        Ok(())
    }

    /// Sets the frequency synthesizer intermediate frequency (in Hertz).
    pub fn set_freq_if(&mut self, hz: u64) -> Result<(), Error<SpiE>> {
        self.0
            .write_register(Config::FSCTRL1, FSCTRL1::default().freq_if(from_freq_if(hz)).bits())?;
        Ok(())
    }

    pub fn set_wor_res(&mut self, wor_res: u8) -> Result<(), Error<SpiE>> {
        self.0.modify_register(Config::WORCTRL, |r| {
            WORCTRL(r).modify().wor_res(wor_res).bits()
        })?;
        Ok(())
    }

    /// Sets the target value for the averaged amplitude from the digital channel filter.
    pub fn set_magn_target(&mut self, target: TargetAmplitude) -> Result<(), Error<SpiE>> {
        self.0.modify_register(Config::AGCCTRL2, |r| {
            AGCCTRL2(r).modify().magn_target(target.into()).bits()
        })?;
        Ok(())
    }

    pub fn set_max_dvga_gain(&mut self, gain: u8) -> Result<(), Error<SpiE>> {
        self.0.modify_register(Config::AGCCTRL2, |r| {
            AGCCTRL2(r).modify().max_dvga_gain(gain).bits()
        })?;
        Ok(())
    }

    /// Sets the filter length (in FSK/MSK mode) or decision boundary (in OOK/ASK mode) for the AGC.
    pub fn set_filter_length(&mut self, filter_length: FilterLength) -> Result<(), Error<SpiE>> {
        self.0.modify_register(Config::AGCCTRL0, |r| {
            AGCCTRL0(r).modify().filter_length(filter_length.into()).bits()
        })?;
        Ok(())
    }

    /// Configures when to run automatic calibration.
    pub fn set_autocalibration(&mut self, autocal: AutoCalibration) -> Result<(), Error<SpiE>> {
        self.0.modify_register(Config::MCSM0, |r| {
            MCSM0(r).modify().fs_autocal(autocal.into()).bits()
        })?;
        Ok(())
    }

    pub fn set_po_timeout(&mut self, timeout: PoTimeout) -> Result<(), Error<SpiE>> {
        self.0.modify_register(Config::MCSM2, |r| {
            MCSM0(r).modify().po_timeout(timeout.into()).bits()
        })?;
        Ok(())
    }

    /// Set Modem deviation setting.
    pub fn set_deviation(&mut self, deviation: u64) -> Result<(), Error<SpiE>> {
        let (mantissa, exponent) = from_deviation(deviation);
        self.0.write_register(
            Config::DEVIATN,
            DEVIATN::default().deviation_m(mantissa).deviation_e(exponent).bits(),
        )?;
        Ok(())
    }

    /// Sets the data rate (in bits per second).
    pub fn set_data_rate(&mut self, baud: u64) -> Result<(), Error<SpiE>> {
        let (mantissa, exponent) = from_drate(baud);
        self.0
            .modify_register(Config::MDMCFG4, |r| MDMCFG4(r).modify().drate_e(exponent).bits())?;
        self.0.write_register(Config::MDMCFG3, MDMCFG3::default().drate_m(mantissa).bits())?;
        Ok(())
    }

    /// Enable Forward Error Correction (FEC) with interleaving for packet payload
    pub fn fec_enable(&mut self, enable: bool) -> Result<(), Error<SpiE>> {
        self.0.modify_register(Config::MDMCFG1, |r| {
            MDMCFG1(r).modify().fec_en(enable as u8).bits()
        })?;
        Ok(())
    }

    pub fn demodulator_freeze_enable(&mut self, enable: bool) -> Result<(), Error<SpiE>> {
        self.0.modify_register(Config::FOCCFG, |r| {
            FOCCFG(r).modify().foc_bs_cs_gate(enable as u8).bits()
        })?;
        Ok(())
    }

    /// Sets the minimum number of preamble bytes to be transmitted
    pub fn set_num_preamble(&mut self, num_preamble: NumPreamble) -> Result<(), Error<SpiE>> {
        self.0.modify_register(Config::MDMCFG1, |r| {
            MDMCFG1(r).modify().num_preamble(num_preamble.into()).bits()
        })?;
        Ok(())
    }

    /// Selects CCA_MODE; Reflected in CCA signal.
    pub fn set_cca_mode(&mut self, cca_mode: CcaMode) -> Result<(), Error<SpiE>> {
        self.0.modify_register(Config::MCSM1, |r| {
            MCSM1(r).modify().cca_mode(cca_mode.into()).bits()
        })?;
        Ok(())
    }

    /// Sets the channel bandwidth (in Hertz).
    pub fn set_chanbw(&mut self, bandwidth: u64) -> Result<(), Error<SpiE>> {
        let (mantissa, exponent) = from_chanbw(bandwidth);
        self.0.modify_register(Config::MDMCFG4, |r| {
            MDMCFG4(r).modify().chanbw_m(mantissa).chanbw_e(exponent).bits()
        })?;
        Ok(())
    }

    /// Configure the sync word to use, and at what level it should be verified.
    pub fn set_sync_mode(&mut self, sync_mode: SyncMode) -> Result<(), Error<SpiE>> {
        let reset: u16 = (SYNC1::default().bits() as u16) << 8 | (SYNC0::default().bits() as u16);

        let (mode, word) = match sync_mode {
            SyncMode::Disabled => (SyncCheck::DISABLED, reset),
            SyncMode::MatchPartial(word) => (SyncCheck::CHECK_15_16, word),
            SyncMode::MatchPartialRepeated(word) => (SyncCheck::CHECK_30_32, word),
            SyncMode::MatchFull(word) => (SyncCheck::CHECK_16_16, word),
            SyncMode::MatchPartialRepeatedCS(word) => (SyncCheck::CHECK_30_32_CS, word),
        };
        self.0.modify_register(Config::MDMCFG2, |r| {
            MDMCFG2(r).modify().sync_mode(mode.into()).bits()
        })?;
        self.0.write_register(Config::SYNC1, ((word >> 8) & 0xff) as u8)?;
        self.0.write_register(Config::SYNC0, (word & 0xff) as u8)?;
        Ok(())
    }

    /// Set the modulation format of the radio signal.
    pub fn set_modulation_format(
        &mut self,
        mod_format: ModulationFormat,
    ) -> Result<(), Error<SpiE>> {
        self.0.modify_register(Config::MDMCFG2, |r| {
            MDMCFG2(r).modify().mod_format(mod_format.into()).bits()
        })?;
        Ok(())
    }

    /// Enable automatic flush of RX FIFO when CRC is not OK.
    /// This requires that only one packet is in the RX FIFO and that packet length is limited to the RX FIFO size.
    pub fn crc_autoflush_enable(&mut self, enable: bool) -> Result<(), Error<SpiE>> {
        self.0.modify_register(Config::PKTCTRL1, |r| {
            PKTCTRL1(r).modify().crc_autoflush(enable as u8).bits()
        })?;
        Ok(())
    }

    /// When enabled, two status bytes will be appended to the payload of the packet.
    /// The status bytes contain RSSI and LQI values, as well as CRC OK.
    pub fn append_status_enable(&mut self, enable: bool) -> Result<(), Error<SpiE>> {
        self.0.modify_register(Config::PKTCTRL1, |r| {
            PKTCTRL1(r).modify().append_status(enable as u8).bits()
        })?;
        Ok(())
    }

    pub fn set_fscal3(&mut self, value: u8) -> Result<(), Error<SpiE>> {
        self.0.modify_register(Config::FSCAL3, |r| {
            FSCAL3(r).modify().fscal3(value).bits()
        })?;
        Ok(())
    }

    pub fn vco_core_enable(&mut self, enable: bool) -> Result<(), Error<SpiE>> {
        self.0.modify_register(Config::FSCAL2, |r| {
            FSCAL2(r).modify().vco_core_h_en(enable as u8).bits()
        })?;
        Ok(())
    }

    pub fn vco_sel_cal_enable(&mut self, enable: bool) -> Result<(), Error<SpiE>> {
        self.0.modify_register(Config::TEST0, |r| {
            TEST0(r).modify().vco_sel_cal_en(enable as u8).bits()
        })?;
        Ok(())
    }

    pub fn set_pqt(&mut self, pqt: u8) -> Result<(), Error<SpiE>> {
        self.0.modify_register(Config::PKTCTRL1, |r| {
            PKTCTRL1(r).modify().pqt(pqt).bits()
        })?;
        Ok(())
    }

    /// Configure device address, and address filtering.
    pub fn set_address_filter(&mut self, filter: AddressFilter) -> Result<(), Error<SpiE>> {
        self.0.address_field = true;
        let (mode, addr) = match filter {
            AddressFilter::Disabled => {
                self.0.address_field = false;
                (AddressCheck::DISABLED, ADDR::default().bits())
            }
            AddressFilter::Device(addr) => (AddressCheck::SELF, addr),
            AddressFilter::DeviceLowBroadcast(addr) => (AddressCheck::SELF_LOW_BROADCAST, addr),
            AddressFilter::DeviceHighLowBroadcast(addr) => {
                (AddressCheck::SELF_HIGH_LOW_BROADCAST, addr)
            }
        };
        self.0.modify_register(Config::PKTCTRL1, |r| {
            PKTCTRL1(r).modify().adr_chk(mode.into()).bits()
        })?;
        self.0.write_register(Config::ADDR, addr)?;
        Ok(())
    }

    pub fn set_power(&mut self, power: Power) -> Result<(), Error<SpiE>> {
        self.0.write_register(Config::PATABLE, power as u8)?;
        Ok(())
    }

    pub fn set_gdo0_cfg(&mut self, cfg: Gdo0Cfg) -> Result<(), Error<SpiE>> {
        self.0.write_register(Config::IOCFG0, cfg as u8)?;
        Ok(())
    }

    pub fn set_fifo_threshold(&mut self, threshold: FifoThreshold) -> Result<(), Error<SpiE>> {
        self.0.modify_register(Config::FIFOTHR, |r| {
            FIFOTHR(r).modify().fifo_thr(threshold.into()).bits()
        })?;
        Ok(())
    }

    /// Debugging function to directly write registers
    pub fn set_register<R>(&mut self, addr: R, value: u8) -> Result<(), Error<SpiE>>
    where
        R: Into<Register>,
    {
        self.0.write_register(addr, value)?;
        Ok(())
    }

    pub fn adc_retention_enable(&mut self, enable: bool) -> Result<(), Error<SpiE>> {
        self.0.modify_register(Config::FIFOTHR, |r| {
            FIFOTHR(r).modify().adc_retention(enable as u8).bits()
        })?;
        Ok(())
    }

    /// Turn data whitening on / off.
    pub fn white_data_enable(&mut self, enable: bool) -> Result<(), Error<SpiE>> {
        self.0.modify_register(Config::PKTCTRL0, |r| {
            PKTCTRL0(r).modify().white_data(enable as u8).bits()
        })?;
        Ok(())
    }

    /// Enable CRC calculation in TX and CRC check in RX
    pub fn crc_enable(&mut self, enable: bool) -> Result<(), Error<SpiE>> {
        self.0.modify_register(Config::PKTCTRL0, |r| {
            PKTCTRL0(r).modify().crc_en(enable as u8).bits()
        })?;
        Ok(())
    }

    /// Configure packet mode, and length.
    pub fn set_packet_length(&mut self, length: PacketLength) -> Result<(), Error<SpiE>> {
        let (format, pktlen) = match length {
            PacketLength::Fixed(limit) => (LengthConfig::FIXED, limit),
            PacketLength::Variable(max_limit) => {
                self.0.length_field = true;
                (LengthConfig::VARIABLE, max_limit)
            }
            PacketLength::Infinite => (LengthConfig::INFINITE, PKTLEN::default().bits()),
        };
        self.0.modify_register(Config::PKTCTRL0, |r| {
            PKTCTRL0(r).modify().length_config(format.into()).bits()
        })?;
        self.0.write_register(Config::PKTLEN, pktlen)?;
        Ok(())
    }

    /// Read hardware information: part number for CC1101 and current version number
    pub fn get_hw_info(&mut self) -> Result<(u8, u8), Error<SpiE>> {
        let partnum = self.0.read_register(Status::PARTNUM)?;
        let version = self.0.read_register(Status::VERSION)?;
        Ok((partnum, version))
    }

    /// Read Frequency Offset Estimate from Demodulator
    /// Frequency offset compensation is only supported for 2-FSK, GFSK, 4-FSK, and MSK modulation.
    /// This register will read 0 when using ASK or OOK modulation.
    pub fn get_est_freq_offset(&mut self) -> Result<i32, Error<SpiE>> {
        Ok(to_frequency_offset(self.0.read_register(Status::FREQEST)?))
    }

    /// Read Link Quality Indicator.
    /// Note: Register field LQI.CRC_OK is ignored in this read because it's available also in the PKTSTATUS.CRC_OK register field.
    pub fn get_lqi(&mut self) -> Result<u8, Error<SpiE>> {
        Ok(LQI(self.0.read_register(Status::LQI)?).lqi())
    }

    /// Received Signal Strength Indicator is an estimate of the signal power level in the chosen channel.
    pub fn get_rssi_dbm(&mut self) -> Result<i16, Error<SpiE>> {
        Ok(from_rssi_to_rssi_dbm(self.0.read_register(Status::RSSI)?))
    }

    /// Read the Machine State
    pub fn get_machine_state(&mut self) -> Result<MachineState, Error<SpiE>> {
        let marcstate = MARCSTATE(self.0.read_register(Status::MARCSTATE)?);

        match MachineState::try_from(marcstate.marc_state()) {
            Ok(state) => Ok(state),
            Err(e) => match e {
                MachineStateError::InvalidState(value) => Err(Error::InvalidState(value)),
            },
        }
    }

    /// Read the Current GDOx Status and Packet Status
    pub fn get_packet_status(&mut self) -> Result<PacketStatus, Error<SpiE>> {
        Ok(PKTSTATUS(self.0.read_register(Status::PKTSTATUS)?).into())
    }

    /// Read number of bytes in TX FIFO
    pub fn get_tx_bytes(&mut self) -> Result<u8, Error<SpiE>> {
        let txbytes = TXBYTES(self.0.read_register(Status::TXBYTES)?);
        let num_txbytes: u8 = txbytes.num_txbytes();

        if txbytes.txfifo_underflow() != 0 {
            return Err(Error::TxUnderflow);
        }

        Ok(num_txbytes)
    }

    /// Read number of bytes in RX FIFO
    pub fn get_rx_bytes(&mut self) -> Result<u8, Error<SpiE>> {
        let rxbytes = RXBYTES(self.0.read_register(Status::RXBYTES)?);
        let num_rxbytes: u8 = rxbytes.num_rxbytes();

        //if rxbytes.rxfifo_overflow() != 0 {
        //    return Err(Error::RxOverflow);
        //}

        Ok(num_rxbytes)
    }

    fn await_chip_state(&mut self, target: State) -> Result<(), Error<SpiE>> {
        loop {
            let state = self.fetch_chip_state()?;
            if state == target {
                break;
            }

            #[cfg(feature = "std")]
            sleep(Duration::from_millis(50));
        }
        Ok(())
    }

    /// Read data from FIFO
    pub fn read_data(
        &mut self,
        length: &mut Option<u8>,
        address: &mut Option<u8>,
        data: &mut [u8],
    ) -> Result<(), Error<SpiE>> {
        let num_of_optional_fields = self.0.length_field as usize + self.0.address_field as usize;
        let data_len_max: usize = FIFO_SIZE_MAX as usize - num_of_optional_fields;
        let mut optional_fields = [0, 0];
        let mut index = 0;

        // Validate Length parameter
        if self.0.length_field && length.is_none() {
            return Err(Error::UserInputError(UserError::MissingLengthParameter));
        }

        // Validate Address parameter
        if self.0.address_field && address.is_none() {
            return Err(Error::UserInputError(UserError::MissingAddressParameter));
        }

        if data.len() <= data_len_max {
            self.0.access_fifo(
                Access::Read,
                &mut optional_fields[..num_of_optional_fields],
                data,
            )?;

            if self.0.length_field {
                *length = Some(optional_fields[index]);
                index += 1;
            }

            if self.0.address_field {
                *address = Some(optional_fields[index]);
            }
        } else {
            return Err(Error::UserInputError(UserError::ArrayTooLong(data.len())));
        }
        Ok(())
    }

    /// Write data into FIFO
    pub fn write_data(
        &mut self,
        length: &mut Option<u8>,
        address: &mut Option<u8>,
        data: &mut [u8],
    ) -> Result<(), Error<SpiE>> {
        let num_of_optional_fields = self.0.length_field as usize + self.0.address_field as usize;
        let data_len_max: usize = FIFO_SIZE_MAX as usize - num_of_optional_fields;
        let mut optional_fields = [0, 0];
        let mut index = 0;

        // Validate Length parameter
        if self.0.length_field && length.is_none() {
            return Err(Error::UserInputError(UserError::MissingLengthParameter));
        }

        // Validate Address parameter
        if self.0.address_field && address.is_none() {
            return Err(Error::UserInputError(UserError::MissingAddressParameter));
        }

        if data.len() <= data_len_max {
            if self.0.length_field {
                optional_fields[index] = (*length).unwrap();
                index += 1;
            }

            if self.0.address_field {
                optional_fields[index] = (*address).unwrap();
            }

            self.0.access_fifo(
                Access::Write,
                &mut optional_fields[..num_of_optional_fields],
                data,
            )?;
        } else {
            return Err(Error::UserInputError(UserError::ArrayTooLong(data.len())));
        }
        Ok(())
    }

    fn await_machine_state(&mut self, target_state: MachineState) -> Result<(), Error<SpiE>> {
        loop {
            let machine_state = self.get_machine_state()?;
            if target_state == machine_state {
                break;
            }
        }
        Ok(())
    }

    /// Configure some default settings, to be removed in the future.
    #[rustfmt::skip]
    pub fn set_defaults(&mut self) -> Result<(), Error<SpiE>> {
        self.reset_chip()?;

        self.0.write_register(Config::PKTCTRL0, PKTCTRL0::default()
            .white_data(0).bits()
        )?;

        self.set_freq_if(203_125)?;

        self.0.write_register(Config::MDMCFG2, MDMCFG2::default()
            .dem_dcfilt_off(1).bits()
        )?;

        self.set_autocalibration(AutoCalibration::FromIdle)?;

        self.0.write_register(Config::AGCCTRL2, AGCCTRL2::default()
            .max_lna_gain(0x04).bits()
        )?;

        Ok(())
    }

    /// Set radio in Idle/Sleep/Calibrate/Transmit/Receive mode.
    pub fn set_radio_mode(&mut self, radio_mode: RadioMode) -> Result<(), Error<SpiE>> {
        let target = match radio_mode {
            RadioMode::Idle => {
                self.exit_rx_tx()?;
                MachineState::IDLE
            }
            RadioMode::Sleep => {
                self.set_radio_mode(RadioMode::Idle)?;
                self.enter_power_down_mode()?;
                MachineState::SLEEP
            }
            RadioMode::Calibrate => {
                self.set_radio_mode(RadioMode::Idle)?;
                self.cal_freq_synth_and_turn_off()?;
                MachineState::MANCAL
            }
            RadioMode::Transmit => {
                self.set_radio_mode(RadioMode::Idle)?;
                self.enable_tx()?;
                MachineState::TX
            }
            RadioMode::Receive => {
                self.set_radio_mode(RadioMode::Idle)?;
                self.enable_rx()?;
                MachineState::RX
            }
        };
        self.await_machine_state(target)
    }

    fn rx_bytes_available(&mut self) -> Result<u8, Error<SpiE>> {
        let num_rxbytes = self.get_rx_bytes()?;
        Ok(num_rxbytes)
    }

    fn tx_bytes(&mut self) -> Result<u8, Error<SpiE>> {
        let num_txbytes = self.get_tx_bytes()?;
        Ok(num_txbytes)
    }

    pub fn set_idle_state(&mut self) -> Result<(), Error<SpiE>> {
        self.0.write_cmd_strobe(Command::SIDLE)?;
        while self.fetch_chip_state()? != State::IDLE {
            #[cfg(feature = "std")]
            sleep(Duration::from_millis(50));
        }
        Ok(())
    }

    pub fn set_rx_state(&mut self) -> Result<(), Error<SpiE>> {
        loop {
            let state = self.fetch_chip_state()?;
            match state {
                State::IDLE => self.0.write_cmd_strobe(Command::SIDLE)?,
                State::RX => break,
                State::RXFIFO_OVERFLOW => self.0.write_cmd_strobe(Command::SFRX)?,
                State::TXFIFO_UNDERFLOW => self.0.write_cmd_strobe(Command::SFTX)?,
                _ => {}
            }
            self.0.write_cmd_strobe(Command::SRX)?;
            #[cfg(feature = "std")]
            sleep(Duration::from_millis(50));
        }
        Ok(())
    }

    pub fn set_tx_state(&mut self) -> Result<(), Error<SpiE>> {
        self.0.write_cmd_strobe(Command::STX)?;
        Ok(())
    }

    /// Should also be able to configure MCSM1.RXOFF_MODE to declare what state
    /// to enter after fully receiving a packet.
    /// Possible targets: IDLE, FSTON, TX, RX
    pub fn receive(&mut self, length: &mut u8, buf: &mut [u8]) -> Result<[u8; 2], Error<SpiE>> {
        if self.fetch_chip_state()? == State::RX {
            return Err(Error::InvalidState(1));
        }

        match self.rx_bytes_available() {
            Ok(_nbytes) => {
                // Assume we are in variable packet length mode
                // FIrst byte is the length of the packet
                *length = self.0.read_fifo_single()?;

                // Read the payload
                if *length as usize > buf.len() {
                    self.set_idle_state()?;
                    self.flush_rx_fifo_buffer()?;
                    self.set_rx_state()?;
                    return Err(Error::RxOverflow);
                }
                self.0.read_fifo(buf, *length)?;

                // Read status bytes (2 bytes)
                let mut status = [0u8; 2];
                self.0.read_fifo(&mut status, 2)?;

                let lqi = status[1];
                if (lqi >> 7) != 1 {
                    Err(Error::CrcMismatch)
                } else {
                    Ok(status)
                }
            }
            Err(err) => {
                self.set_idle_state()?;
                self.flush_rx_fifo_buffer()?;
                self.set_rx_state()?;
                Err(err)
            }
        }
    }

    pub fn transmit(&mut self, data: &mut [u8], length: u8) -> Result<(), Error<SpiE>> {
        match self.tx_bytes() {
            Ok(_) => {
                self.set_idle_state()?;
                self.flush_tx_fifo_buffer()?;
                self.flush_rx_fifo_buffer()?;
                self.set_idle_state()?;

                self.await_chip_state(State::IDLE)?;

                self.enable_tx()?;

                // dismiss if state is 1 (RX)
                // (mineiwik) probably no longer required
                let state = self.fetch_chip_state()?;
                if state == State::RX {
                    return Err(Error::InvalidState(state as u8));
                }

                self.0.write_fifo_single(length as u8)?;
                self.0.write_fifo(&mut data[0..length as usize])?;

                self.await_chip_state(State::IDLE)?;

                self.set_idle_state()?;
                self.flush_tx_fifo_buffer()?;
                self.set_rx_state()?;
                Ok(())
            }
            Err(err) => Err(err),
        }
    }

    /// Configures raw data to be passed through, without any packet handling.
    pub fn set_raw_mode(&mut self) -> Result<(), Error<SpiE>> {
        // Serial data output.
        self.0.write_register(Config::IOCFG0, 0x0d)?;
        // Disable data whitening and CRC, fixed packet length, asynchronous serial mode.
        self.0.write_register(Config::PKTCTRL0, 0x30)?;
        Ok(())
    }

}
